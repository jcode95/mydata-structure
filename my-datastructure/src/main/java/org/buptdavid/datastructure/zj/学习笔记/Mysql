
Innodb存储引擎
	工作方式（工作主要是使用后台的1个master线程来完成的）:将数据库文件按页（每页16k）读取到缓冲池，然后按照最近使用最少的LRU算法来保留到缓冲池中的数据
		如果修数据库文件需要修改。首先修改缓冲池的数据，然后再按照一定的频率刷新缓冲池里面脏页（修改过就属于脏页）刷新到文件。
	后台线程有7个，4个io（1个read，1个log，1个write,1个insert buffer ）
	1个master 1个lock  1个error
	内存包括：
		缓冲池（占最大内存块），重做日志缓冲池，额外的内存池
	缓冲池里面的数据页的类型有（索引页，数据页，undo页等），
现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们总结一下：
		1、InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。
		2、索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；
		那么回到我们开始的问题，通常一棵B+树可以存放多少行数据？
		这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。
		上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。
		那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。
		根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时 一次页的查找代表一次IO， 所以通过主键索引查询通常 只需要1-3次IO操作 即可查找到数据。



MyISAM与InnoDB的区别？
1、InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
2、InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
3、
    3.1）InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），
    必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
    3.2） MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

    也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
    （ps MyISAM 有 MYI索引文件 和 MYD数据文件。MYI就是索引文件，底层使用B+Tree 结构，MYI的叶子节点存储的是MYD数据文件的地址指针，所以会通过MYI找到MYD数据文件对应的数据）
    （ps Innodb 有IDB索引数据文件，底层也是使用B+Tree 因为主键与数据文件绑定在一起，叶子节点存放的就是数据文件）
4、 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；
    那么为什么InnoDB没有了这个变量呢？
        因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。
        如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS
5、Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了
6、MyISAM表格可以被压缩后进行查询操作
7、InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有
9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI
      Innodb：frm是表定义文件，ibd是数据文件
      Myisam：frm是表定义文件，myd是数据文件，myi是索引文件


如何选择：
    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
    2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。
    3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；
    4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。
InnoDB为什么推荐使用自增ID作为主键？
    答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。
innodb引擎的4大特性
       插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)

以上文章来自于：https://blog.csdn.net/qq_35642036/article/details/82820178